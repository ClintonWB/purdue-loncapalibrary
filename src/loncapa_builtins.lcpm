#init some globals
$hidden::RANDOMINIT=0;
$pi=atan2(1,1)*4;
$rad2deg=180.0/$pi;
$deg2rad=$pi/180.0;
$"=' ';

sub cas {
    my ($system,$input,$library)=@_;
    my $output;
    my $dump;
    if ($system eq 'maxima') {
       $output=&maxima_eval($input,$library);
    } elsif ($system eq 'R') {
       ($output,$dump)=&r_eval($input,$library,0);
    } else {
       $output='Error: unrecognized CAS';
    }
    return $output;
}

sub cas_hashref {
    my ($system,$input,$library)=@_;
    if ($system eq 'maxima') {
       return 'Error: unsupported CAS';
    } elsif ($system eq 'R') {
       return &r_eval($input,$library,1);
    } else {
       return 'Error: unrecognized CAS';
    }
}

#
# cas_hashref_entry takes a list of indices and gets the entry in a hash generated by Rreturn.
# Call: cas_hashref_entry(Rvalue, index1, index2, ...) where Rvalue is a hash returned by Rreturn.
# Rentry will return the first scalar value it encounters (ignoring excess indices).
# If an invalid key is given, it returns undef.
#
sub cas_hashref_entry {
    return &Rentry(@_);
}

#
# cas_hashref_array takes a list of indices and gets a column array from a hash generated by Rreturn.
# Call: cas_hashref_array(Rvalue, index1, index2, ...) where Rvalue is a hash returned by Rreturn.
# If an invalid key is given, it returns undef.
#
sub cas_hashref_array {
    return &Rarray(@_);
}

sub tex {
    if ( $external::target eq "tex" ) {
	return $_[0];
    } else {
	return $_[1];
    }
}

sub var_in_tex {
    if ( $external::target eq "tex" ) {
	return $_[0];
    } else {
	return "";
    }
}

sub web {
    if ( $external::target eq "tex" ) {
	return $_[1];
    } else {
	if ( $external::target eq "web" || $external::target eq "answer") {
	    return $_[2];
	} else {
	    return $_[0];
	}
    }
}

sub html {
    if ( $external::target eq "web" ) {
	return shift;
    }
}

sub hinton {
    return 0;
}

sub random {
    my ($start,$end,$step)=@_;
    if ( ! $hidden::RANDOMINIT ) {
	if ($external::randomseed == 0) { $external::randomseed=1; }
	if ($external::randomseed =~/,/) {
	    my ($num1,$num2)=split(/,/,$external::randomseed);
	    &random_set_seed(1,abs($num1));
	} elsif ($external::randomseed =~/:/) {
	    my ($num1,$num2)=split(/:/,$external::randomseed);
	    &random_set_seed(abs($num1),abs($num2));
	} else {
	    &random_set_seed(1,int(abs($external::randomseed)));
	}
	&math_random_uniform();
	$hidden::RANDOMINIT=1;
    }
    if (!defined($step)) { $step=1; }
    my $num=1+int(($end-$start)/$step);
    my $result=$start + int(&math_random_uniform() * $num)*$step;
    return $result;
}

sub random_normal {
    my ($item_cnt,$seed,$av,$std_dev) = @_;
    my @oldseed=&random_get_seed();
    my @retArray;
    &random_set_seed_from_phrase($seed);
    @retArray=&math_random_normal($item_cnt,$av,$std_dev);
    &random_set_seed(@oldseed);
    return @retArray;
}

sub random_beta {
    my ($item_cnt,$seed,$aa,$bb) = @_;
    my @oldseed=&random_get_seed();
    my @retArray;
    &random_set_seed_from_phrase($seed);
    @retArray=&math_random_beta($item_cnt,$aa,$bb);
    &random_set_seed(@oldseed);
    return @retArray;
}

sub random_gamma {
    my ($item_cnt,$seed,$a,$r) = @_;
    my @oldseed=&random_get_seed();
    my @retArray;
    &random_set_seed_from_phrase($seed);
    @retArray=&math_random_gamma($item_cnt,$a,$r);
    &random_set_seed(@oldseed);
    return @retArray;
}

sub random_exponential {
    my ($item_cnt,$seed,$av) = @_;
    my @oldseed=&random_get_seed();
    my @retArray;
    &random_set_seed_from_phrase($seed);
    @retArray=&math_random_exponential($item_cnt,$av);
    &random_set_seed(@oldseed);
    return @retArray;
}

sub random_poisson {
    my ($item_cnt,$seed,$mu) = @_;
    my @oldseed=&random_get_seed();
    my @retArray;
    &random_set_seed_from_phrase($seed);
    @retArray=&math_random_poisson($item_cnt,$mu);
    &random_set_seed(@oldseed);
    return @retArray;
}

sub random_chi {
    my ($item_cnt,$seed,$df) = @_;
    my @oldseed=&random_get_seed();
    my @retArray;
    &random_set_seed_from_phrase($seed);
    @retArray=&math_random_chi_square($item_cnt,$df);
    &random_set_seed(@oldseed);
    return @retArray;
}

sub random_noncentral_chi {
    my ($item_cnt,$seed,$df,$nonc) = @_;
    my @oldseed=&random_get_seed();
    my @retArray;
    &random_set_seed_from_phrase($seed);
    @retArray=&math_random_noncentral_chi_square($item_cnt,$df,$nonc);
    &random_set_seed(@oldseed);
    return @retArray;
}

sub random_f {
    my ($item_cnt,$seed,$dfn,$dfd) = @_;
    my @oldseed=&random_get_seed();
    my @retArray;
    &random_set_seed_from_phrase($seed);
    @retArray=&math_random_f($item_cnt,$dfn,$dfd);
    &random_set_seed(@oldseed);
    return @retArray;
}

sub random_noncentral_f {
    my ($item_cnt,$seed,$dfn,$dfd,$nonc) = @_;
    my @oldseed=&random_get_seed();
    my @retArray;
    &random_set_seed_from_phrase($seed);
    @retArray=&math_random_noncentral_f($item_cnt,$dfn,$dfd,$nonc);
    &random_set_seed(@oldseed);
    return @retArray;
}

sub random_multivariate_normal {
    my ($item_cnt,$seed,$mean,$covar) = @_;
    my @oldseed=&random_get_seed();
    &random_set_seed_from_phrase($seed);
    my @retArray=&math_random_multivariate_normal($item_cnt,@$mean,@$covar);
    &random_set_seed(@oldseed);
    return @retArray;
}

sub random_multinomial {
    my ($item_cnt,$seed,@p) = @_;
    my @oldseed=&random_get_seed();
    my @retArray;
    &random_set_seed_from_phrase($seed);
    my @retArray=&math_random_multinomial($item_cnt,@p);
    &random_set_seed(@oldseed);
    return @retArray;
}

sub random_permutation {
    my ($seed,@inArray) = @_;
    my @oldseed=&random_get_seed();
    my @retArray;
    &random_set_seed_from_phrase($seed);
    @retArray=&math_random_permutation(@inArray);
    &random_set_seed(@oldseed);
    return @retArray;
}

sub random_uniform {
    my ($item_cnt,$seed,$low,$high) = @_;
    my @oldseed=&random_get_seed();
    my @retArray;
    &random_set_seed_from_phrase($seed);
    @retArray=&math_random_uniform($item_cnt,$low,$high);
    &random_set_seed(@oldseed);
    return @retArray;
}

sub random_uniform_integer {
    my ($item_cnt,$seed,$low,$high) = @_;
    my @oldseed=&random_get_seed();
    my @retArray;
    &random_set_seed_from_phrase($seed);
    @retArray=&math_random_uniform_integer($item_cnt,$low,$high);
    &random_set_seed(@oldseed);
    return @retArray;
}

sub random_binomial {
    my ($item_cnt,$seed,$nt,$p) = @_;
    my @oldseed=&random_get_seed();
    my @retArray;
    &random_set_seed_from_phrase($seed);
    @retArray=&math_random_binomial($item_cnt,$nt,$p);
    &random_set_seed(@oldseed);
    return @retArray;
}

sub random_negative_binomial {
    my ($item_cnt,$seed,$ne,$p) = @_;
    my @oldseed=&random_get_seed();
    my @retArray;
    &random_set_seed_from_phrase($seed);
    @retArray=&math_random_negative_binomial($item_cnt,$ne,$p);
    &random_set_seed(@oldseed);
    return @retArray;
}

sub abs { CORE::abs(shift) }
sub sin { CORE::sin(shift) }
sub cos { CORE::cos(shift) }
sub exp { CORE::exp(shift) }
sub int { CORE::int(shift) }
sub log { CORE::log(shift) }
sub ln { CORE::log(shift) }
sub atan2 { CORE::atan2($_[0],$_[1]) }
sub sqrt { CORE::sqrt(shift) }

sub tan  { CORE::sin($_[0]) / CORE::cos($_[0]) }
#sub atan { atan2($_[0], 1); }
#sub acos { atan2(sqrt(1 - $_[0] * $_[0]), $_[0] ); }
#sub asin { atan2($_[0], sqrt(1- $_[0] * $_[0]) );  }

sub log10 { CORE::log($_[0])/CORE::log(10); }

sub factorial {
    my $input = CORE::int(shift);
    return "Error - unable to take factorial of an negative number ($input)" if $input < 0;
    return "Error - factorial result is greater than system limit ($input)" if $input > 170;
    return 1 if $input == 0;
    my $result = 1; 
    for (my $i=2; $i<=$input; $i++) { $result *= $i }
    return $result;
}

sub sgn {
    return -1 if $_[0] < 0;
    return 0 if $_[0] == 0;
    return 1 if $_[0] > 0;
}

sub min {
    my @sorted = sort { $a <=> $b || $a cmp $b } @_;
    return shift @sorted;
}

sub max {
    my @sorted = sort { $a <=> $b || $a cmp $b } @_;
    return pop @sorted;
}

sub roundto {
    my ($input,$n) = @_;
    return sprintf('%.'.$n.'f',$input);
}

sub to_string {
    my ($input,$n) = @_;
    return sprintf($input) if $n eq "";
    $n = '.'.$n if $n !~ /^\./;
    return sprintf('%'.$n,$input) if $n ne "";
}

sub sub_string {
    my ($str,$start,$len) = @_;
    return substr($str,$start-1,$len);
}

sub pow   {return $_[0] ** $_[1]; }
sub ceil  {return (($_[0]-CORE::int($_[0]))== 0.0) ? $_[0] : (($_[0] > 0) ? (CORE::int($_[0])+ 1) : CORE::int($_[0])); }
sub floor  {return (($_[0]-CORE::int($_[0]))== 0.0) ? $_[0] : (($_[0] > 0) ? CORE::int($_[0]) : (CORE::int($_[0])-1)); }

sub format {
    my ($value,$fmt)=@_;
    my ($dollarmode,$commamode,$alwaysperiod,$options);
    if ($fmt =~ /^([^\d]*)(.*)/) { $options=$1; $fmt=$2; } 
    #if ($options =~ /\$/) { $dollamode=1; }
    #if ($options =~ /,/)  { $commamode=1; }
    if ($options =~ /\./) { $alwaysperiod=1; }
    my $result;
    if ($fmt=~/s$/i) {
	$result=&format_significant_figures($value,$fmt);
    } else {
	$fmt=~s/e/E/g;
	$result=sprintf('%.'.$fmt,$value);
	if ($alwaysperiod && $fmt eq '0f') { $result .='.'; }
	$result=~s/(E[+-]*)0/$1/;
    }
    #if ($dollarmode) {$result=&dollarformat($result);}
    #if ($commamode) {$result=&commaformat($result);}
    return $result;
}

sub chemparse {
    my ($reaction) = @_;
    my @tokens = split(/(\s\+|\->|<=>|<\-|\.)/,$reaction);
    my $formula = '';
    foreach my $token (@tokens) {
	if ($token eq '->' ) {
	    $formula .= '<m>\ensuremath{\rightarrow}</m> ';
	    next;
	}
	if ($token eq '<-' ) {
	    $formula .= '<m>\ensuremath{\leftarrow}</m> ';
	    next;
	}  
	if ($token eq '<=>') {
	    if ($external::target eq 'web' &&
		&EXT('request.browser.unicode')) {
		$formula .= '&#8652; ';
	    } else {
		$formula .= &web('<=> ','<m>\ensuremath{\rightleftharpoons}</m> ',
				 '&lt;=&gt; ');
	    }
	    next;
	}
	if ($token eq '.') {
	  $formula =~ s/(\&nbsp\;| )$//;
	  $formula .= '&middot;';
	  next;
	}
	$token =~ /^\s*([\d|\/]*(?:&frac\d\d)?)(.*)/;
        $formula .= $1 if ($1 ne '1');  # stoichiometric coefficient
	
	my $molecule = $2;
	# subscripts
	$molecule =~ s|(?<=[a-zA-Z\)\]\s])(\d+)|<sub>$1</sub>|g;
	# superscripts
	$molecule =~ s|\^(\d*[+\-]*)|<sup>$1</sup>|g;
	# strip whitespace
	$molecule =~ s/\s*//g;
	# forced space
	$molecule =~ s/_/ /g;
	$molecule =~ s/-/&minus;/g;
	$formula .= $molecule.'&nbsp;';
    }
    # get rid of trailing space
    $formula =~ s/(\&nbsp\;| )$//;
    return &xmlparse($formula);
}

sub prettyprint {
    my ($value,$fmt,$target)=@_;
    my $result;
    if (!$target) { $target = $external::target; }
    if ($fmt =~ /chem/i) { return(&chemparse($value)); }
    my ($dollarmode,$commamode,$alwaysperiod,$options);
    if ($fmt =~ /^([^\d]*)(.*)/) { $options=$1; $fmt=$2; } 
    if ($options =~ /\$/) { $dollarmode=1; }
    if ($options =~ /,/)  { $commamode=1; }
    if ($options =~ /\./) { $alwaysperiod=1; }
    if ($fmt=~/s$/i) {
	$value=&format_significant_figures($value,$fmt);
    } elsif ($fmt) {
	$value=sprintf('%.'.$fmt,$value);
    }
    if ($alwaysperiod && $fmt eq '0f') {
	if ($target eq 'tex') {
	    $value .='\\ensuremath{.}';
	} else {
	    $value .='.';
	}
    }
    if ($value =~ /([0-9\.\-\+]+)E([0-9\-\+]+)/i ) {
	my $frac=$1;
	if ($dollarmode) { $frac=&dollarformat($frac); }
	if ($commamode) { $frac=&commaformat($frac); }
	my $exponent=$2;
	$exponent=~s/^\+0*//;
	$exponent=~s/^-0*/-/;
	$exponent=~s/^-0*/-/;
	if ($exponent eq '-') { undef($exponent); }
	if ($exponent) {
	    if ($target eq 'web') {
		$result=$frac.'&#215;10<sup>'.$exponent.'</sup>';
	    } elsif ($target eq 'tex') {
		$result='\ensuremath{'.$frac.'\times 10^{'.$exponent.'}}';
	    } else {
		$result=$value;
	    }
	} else {
	    $result=$frac;
	}
    } else {
	$result=$value;
	if    ($dollarmode) { $result=&dollarformat($result,$target); }
	elsif ($commamode)  { $result=&commaformat($result,$target); }
    }
    return $result;
}

sub commaformat {
    my ($number,$target) = @_;
    if ($number =~ /\./) {
	while ($number =~ /([^0-9]*)([0-9]+)([^\.,][^\.,][^\.,])([,0-9]*\.[0-9]*)$/) {
	    $number = $1.$2.','.$3.$4;
	}
    } else {
	while ($number =~ /^([^0-9]*)([0-9]+)([^,][^,][^,])([,0-9]*)$/) {
	    $number = $1.$2.','.$3.$4;
	}
    }
    return $number;
}

sub dollarformat {
    my ($number,$target) = @_;
    if (!$target) { $target = $external::target; }
    $number=&commaformat($number,$target);
    if ($target eq 'tex') {
	$number='\$'.$number; #' stupid emacs
    } else {
	$number='$'.$number; #' stupid emacs
    }
    return $number; 
}

# format of form ns or nS where n is an integer
sub format_significant_figures {
    my ($number,$format) = @_; 
    return '0' if ($number == 0);
    # extract number of significant figures needed
    my ($sig) = ($format =~ /(\d+)s/i);
    # arbitrary choice - suggestions ?? or throw error message?
    $sig = 3 if ($sig eq '');
    # save the minus sign
    my $sign = ($number < 0) ? '-' : '';
    $number = abs($number);
    # needed to correct for a number greater than 1 (or
    my $power = ($number < 1) ? 0 : 1;
    # could round up. Take the integer part of log10.
    my $x10 = int(log($number)/log(10));
    # find number with values left of decimal pt = # of sign figs.
    my $xsig = $number*10**($sig-$x10-$power);
    # get just digits left of decimal pt - also rounds off correctly
    my $xint  = sprintf('%.0f',$xsig);
    # save any trailing zero's
    my ($zeros) = ($xint =~ /(0+)$/);
    # return number to original magnitude
    my $numSig = $xint*10**($x10-$sig+$power);
    if ($numSig =~ /^(\d+)\.(\d+)/) {
        # insert trailing zero's if have decimal point
        my @digarray = split('',$1.$2);
        my $sigcount;
        while (@digarray > 0) {
            my $item = shift(@digarray);
            if ($item) {
                $sigcount = 1 + @digarray;
                last;
            }
        }
        if (($sigcount) && ($sig >= $sigcount)) {
            $zeros = substr($zeros,0,($sig - $sigcount));
        }
        $numSig =~ s/^(\d+)\.(\d+)(\e?(.*)?)$/$1\.$2$zeros$3/;
    } else {
        if ($numSig =~ /^(\d+)e([\+\-]\d+)$/i) {
            my $pre_exp = $1;
            my $exponent = $2;
            $numSig = $pre_exp.'.'.$zeros.'E'.$exponent;
        } elsif ($numSig =~ /0$/) {
            # add decimal pt for number ending with 0 and length == # of sig figs
            if (length($numSig) == $sig) {
                $numSig.='.';
            } elsif (length($numSig) > $sig) {
                # exponential form for number ending with 0 and length > # of sig figs
                my $fmtsig = $sig-1;
                if ($fmtsig) {
                    $numSig = sprintf('%.'.$fmtsig.'E',$numSig);
                }
            } elsif (length($numSig) < $sig) {
                $numSig.='.'.substr($zeros,0,($sig-length($numSig)));
            }
        } else {
            if (length($numSig) < $sig) {
                $numSig.='.'.substr($zeros,0,($sig-length($numSig)));
            }
        }
    }
    # return number with sign
    return $sign.$numSig;
}

sub map {
    my ($phrase,$dest,$source)=@_;
    my @oldseed=&random_get_seed();
    my @seed = &random_seed_from_phrase($phrase);
    &random_set_seed(@seed);
    my $destct = scalar(@$dest);
    if (!$source) {
	my @output;
	my @idx = &math_random_permuted_index($destct);
	my $ctr = 0;
	while ($ctr < $destct) {
	    $output[$ctr] = $$dest[$idx[$ctr]];
	    $ctr++;
	}
        &random_set_seed(@oldseed);
	return @output;
    } else {
	my $num = scalar(@$source);
	my @idx = &math_random_permuted_index($num);
	my $ctr = 0;
	my $tot = $num;
	$tot = $destct if $destct < $num;
	if (ref($$dest[0])) {
	    while ($ctr < $tot) {
		${$$dest[$ctr]} = $$source[$idx[$ctr]];
	        $ctr++;
            }
        } else {
	    while ($ctr < $tot) {
		$$dest[$ctr] = $$source[$idx[$ctr]];
		$ctr++;
	    }
	}
    }
    &random_set_seed(@oldseed);
    return '';
}

sub rmap {
    my ($phrase,$dest,$source)=@_;
    my @oldseed=&random_get_seed();
    my @seed = &random_seed_from_phrase($phrase);
    &random_set_seed(@seed);
    my $destct = scalar(@$dest);
    if (!$source) {
	my @idx = &math_random_permuted_index($destct);
	my $ctr = 0;
	my @r_idx;
	while ($ctr < $destct) {
	    $r_idx[$idx[$ctr]] = $ctr;
	    $ctr++;
	}
	my @output;
	$ctr = 0;
	while ($ctr < $destct) {
	    $output[$ctr] = $$dest[$r_idx[$ctr]];
	    $ctr++;
	}
        &random_set_seed(@oldseed);
	return @output;
    } else {
	my $num = scalar(@$source);
	my @idx = &math_random_permuted_index($num);
	my $ctr = 0;
	my $tot = $num;
	$tot = $destct if $destct < $num;
	my @r_idx;
	while ($ctr < $tot) {
	    $r_idx[$idx[$ctr]] = $ctr;
	    $ctr++;
	}
	$ctr = 0;
	if (ref($$dest[0])) {
	    while ($ctr < $tot) {
		${$$dest[$ctr]} = $$source[$r_idx[$ctr]];
	        $ctr++;
            }
        } else {
	    while ($ctr < $tot) {
		$$dest[$ctr] = $$source[$r_idx[$ctr]];
		$ctr++;
	    }
	}
    }
    &random_set_seed(@oldseed);
    return '';
}

sub capa_id { return }

sub problem { return }

sub name{
    my $fullname = &EXT('environment.lastname').', '.&EXT('environment.firstname').' '.&EXT('environment.middlename');
    $fullname = "" if $fullname eq ",  ";
    $fullname =~ s/\%2d/-/g;
    return $fullname;
}

sub student_number { 
    my $id = &EXT('environment.id');
    $id = '' if $id eq "";
    return $id;
}

sub class {
    my $course = &EXT('course.description');
    $course = '' if $course eq "";
    return $course;
}

sub classid {
    my $courseid = &EXT('request.course.id');
    $courseid = '' if $courseid eq "";
    return $courseid;
}

sub firstname {
    my $firstname = &EXT('environment.firstname');
    $firstname = '' if $firstname eq "";
    return $firstname;
}

sub middlename {
    my $middlename = &EXT('environment.middlename');
    $middlename = '' if $middlename eq "";
    return $middlename;
}

sub lastname {
    my $lastname = &EXT('environment.lastname');
    $lastname = '' if $lastname eq "";
    return $lastname;
}

sub sec { 
    my $sec = &EXT('request.course.sec');
    $sec = '' if $sec eq "";
    return $sec;
}

sub submission {
   my ($partid,$responseid,$subnumber,$encode,$cleanupnum,$mapalias)=@_;
   my $sub='';
   if ($subnumber) { $sub=$subnumber.':'; }
   my $output =
       &EXT('user.resource.'.$sub.'resource.'.$partid.'.'.$responseid.'.submission',$mapalias);
   if (ref($output) eq 'ARRAY') {
       my @items = @{$output};
       if ($encode) {
           @items = map { &encode_response($_); } @items;
       }
       if (ref($cleanupnum) eq 'HASH') {
           @items = map { &cleanup_numerical_response($cleanupnum,$_); } @items;
       }
       return \@items;
   } else {
       if ($encode) {
           $output = &encode_response($output);
       }
       if (ref($cleanupnum) eq 'HASH') {
           $output = &cleanup_numerical_response($cleanupnum,$output);
       }
       return $output;
   }
}

sub encode_response {
    my ($value) = @_;
    $value =~ s/&/&amp;/g;
    $value =~ s/</&lt;/g;
    $value =~ s/>/&gt;/g;
    $value =~ s/"/&quot;/g;
    return $value;
}

sub cleanup_numerical_response {
    my ($cleanupnum,$value) = @_;
    if (ref($cleanupnum) eq 'HASH') {
        if ($cleanupnum->{exponent}) {
            if ($value =~ m{^(.*)[\*xX]\s*10\s*\^\s*(\+|\-)?\s*(\d+)(.*)$}) {
                my $pre_exp = $1;
                my $sign = $2;
                my $exponent = $3;
                my $post_exp = $4;
                if ($pre_exp !~ /\./) {
                    $pre_exp .= '.';
                }
                if ($sign eq '') {
                    $sign = '+';
                }
                $value = $pre_exp.'E'.$sign.$exponent.$post_exp;
            }
        }
        if ($cleanupnum->{comma}) {
            $value =~ s{(\d+),(\d+)}{$1$2};
        }
        if ($cleanupnum->{letterforzero}) {
            $value =~ s/^\s*o(\.\d+)/0$1/i;
        }
        if ($cleanupnum->{spaces}) {
            $value =~ s{^\s+|\s+$}{}g;
            if ($value =~ m{^(.*)\.\s+(\d+)(.*)$}) {
                my $pre_pt = $1;
                my $decimal = $2;
                my $post_dec = $3;
                $value = $pre_pt.'.'.$decimal.$post_dec;
            }
        }
        if ($cleanupnum->{format} =~ /^\d+s$/i) {
            $value = &format_significant_figures($value,$cleanupnum->{format});
        }
    }
    return $value;
}

sub currentpart {
   return $external::part;
}

sub eval_time {
   my ($timestamp)=@_;
   unless ($timestamp) { return ''; }
   return &locallocaltime($timestamp);
}

sub open_date { 
    my ($partid)=@_;
    unless ($partid) { $partid=0; }
    return &eval_time(&EXT('resource.'.$partid.'.opendate'));
}

sub due_date {
    my ($partid)=@_;
    unless ($partid) { $partid=0; } 
    return &eval_time(&EXT('resource.'.$partid.'.duedate'));
}

sub answer_date { 
    my ($partid)=@_;
    unless ($partid) { $partid=0; }
    return &eval_time(&EXT('resource.'.$partid.'.answerdate'));
}

sub open_date_epoch {
    my ($partid)=@_;
    unless ($partid) { $partid=0; }
    return &EXT('resource.'.$partid.'.opendate');
}

sub due_date_epoch {
    my ($partid)=@_;
    unless ($partid) { $partid=0; }
    return &EXT('resource.'.$partid.'.duedate');
}

sub answer_date_epoch {
    my ($partid)=@_;
    unless ($partid) { $partid=0; }
    return &EXT('resource.'.$partid.'.answerdate');
}

sub parameter_setting {
    my ($which,$partid)=@_;
    unless ($partid) { $partid=0; }
    return &EXT('resource.'.$partid.'.'.$which);
}

sub stored_data {
    my ($which,$partid)=@_;
    unless ($partid) { $partid=0; }
    return &EXT('user.resource.resource.'.$partid.'.'.$which);
}

sub wrong_bubbles {
    my ($correct,$lower,$upper,$step,@given)=@_;
    my @array=();
    my %hash=();
    foreach my $new (@given) {
        $hash{$new}=1;
    }
    my $num=int(&parameter_setting('numbubbles',&currentpart()));
    unless ($num) { $num=8; }
    if ($num>1) {
        for (my $i=0;$i<=500;$i++) {
            my $new=&random($lower,$upper,$step);
            if ($hash{$new}) { next; }
            if (abs($new-$correct)<$step) { next; }
            $hash{$new}=1;
            @array=keys(%hash);
            if ($#array+2>=$num) { last; }
        }
    }
    return @array;
}

sub array_moments {
    my @input=@_;
    my (@output,$N);
    $N=scalar (@input);
    $output[0]=$N;
    if ($N <= 1) {
	$output[1]=$input[0];
	$output[1]="Input array not defined" if ($N == 0);
	$output[2]="variance undefined for N<=1";
	$output[3]="skewness undefined for N<=1";
	$output[4]="kurtosis undefined for N<=1";
	return @output;
    }
    my $sum=0;
    foreach my $line (@input) {
	$sum+=$line;
    }
    $output[1] = $sum/$N;
    my ($x,$sdev,$var,$skew,$kurt) = 0;
    foreach my $line (@input) {
	$x=$line-$output[1];
	$var+=$x**2;
	$skew+=$x**3;
	$kurt+=$x**4;
    }
    $output[2]=$var/($N-1);
    $sdev=CORE::sqrt($output[2]);
    if ($sdev == 0) {
	$output[3]="inf-variance=0";
	$output[4]="inf-variance=0";
	return @output;
    }
    $output[3]=$skew/($sdev**3*$N);
    $output[4]=$kurt/($sdev**4*$N)-3;
    return @output;
}

sub choose {
    my $num = $_[0];
    return $_[$num];
}

#&sum1(1,$x,sub { &sum1($_[0],2*$_[0], sub { fact($_[0])**2 })});
#sub sum1 {
#    my ($start,$end,$sub)=@_;
#    my $sum=0;
#    for (my $i=$start;$i<=$end;$i++) {
#        $sum+=&$sub($i);
#    }
#    return $sum
#}

#&sum2('a',1,$x,'&sum2(\'b\',$a,2*$a, \'&factorial($b)**2\')');
#sub sum2 {
#    my ($varname,$start,$end,$line)=@_;
#    my $sum=0;
#    for (my $i=$start;$i<=$end;$i++) {
#	my $func=sub {
#	    eval("\$".$varname."=$i");
#	    eval($line);
#	};
#        $sum+=&$func($i);
#    }
#    return $sum
#}


sub proper_path {
    my ($path)=@_;
    if ( $external::target eq "tex" ) {
	return '/home/httpd/html'.$path;
    } else {
	return $path;
    }
}

